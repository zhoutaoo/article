# 数据培训题纲

[toc]

## Mysql使用

### 数据库类型

**关系型数据库：**

- Oracle 　　　　#主流,付费
- Mysql 　　　　 #主流，开源，使用最多，与Oracle一个公司。
- SqlServer 　　  #注流，微软研发
- DB2                  #IMB研发
- Postgresql        #免费
- Sqlite                #免费，轻量级
- Access              #轻量级

**非关系型数据库：**

NoSQL 数据库，全称为 Not Only SQL，意思就是适用关系型数据库的时候就使用关系型数据库，不适用的时候也没有必要非使用关系型数据库不可，可以考虑使用更加合适的数据存储。主要分为临时性键值存储 （memcached、Redis）、永久性键值存储（Redis）、面向文档的数据库（MongoDB、CouchDB）、 面向列的数据库（Cassandra、HBase），每种 NoSQL 都有其特有的使用场景及优点。

### Mysql简介

mysql是一个开源的关系型数据库，被互联网企业广泛应用。由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。

- Mysql是开源的，所以你不需要支付额外的费用。
- Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
- MySQL使用标准的SQL数据语言形式。
- Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。
- Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。

#### 与商业库对比

**Mysql的优劣势：**

**优势：**

1. 免费、开源，总体拥有成本低。开放性较好，社区活跃。
2. 体积小，灵活方便易用，硬件性能要求不高。
3. 支持多种存储引擎，可以根据场景使用不同存储引擎。

**劣势：**

1. 单库性能低于商业数据库。
2. 对存储过程和触发器等支持不够良好。

#### 概念介绍

##### 常见对象

**instance：**数据库实例，即系统中的一个进程，绑定某端口。

| `对象名称` | `对应关键字` | `描述`                                                       |
| ---------- | ------------ | ------------------------------------------------------------ |
| `库`       | database     | 数据库实例中创建的一个或多个数据集合用于放置表或其它对象，由create database创建 |
| `表`       | table        | 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录 |
| `约束`     | constraint   | 执行数据校验的规则，用于保证数据完整性的规则                 |
| `视图`     | view         | 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据       |
| `索引`     | index        | 用于提高查询性能，相当于书的目录                             |
| `函数`     | function     | 用于完成一次特定的计算，具有一个返回值                       |
| `存储过程` | procedure    | 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境 |
| `触发器 `  | trigger      | 相当于一个事件监听器，当数据库发生特定事件后，触发器被出发，完成相应的处理 |

##### 存储引擎

支持innodb、myIsam、memory等多种存储引擎（可以通过命令：`mysql> show engines;`查看）

innodb：提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。支持自动增长列，支持外键约束。

myIsam：不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表

memory：使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。

#### 索引简介

##### 索引类型

**主键索引：**是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义（因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键），而应该使用BIGINT自增。主键也不应该允许`NULL`。可以使用多个列作为联合主键，但联合主键并不常用。

**普通索引：**这是最基本的索引，由关键字KEY或INDEX定义的索引，唯一任务是加快对数据的访问速度。

**唯一索引：**与普通索引相比，只是索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

**复合索引：**索引可以覆盖多个数据列，如像INDEX（columnA，columnB）索引。这种索引的特点是MySQL可以有选择地使用一个这样的索引。

**外键索引：**如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。

**全文索引：**是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。

##### 索引结构

InnoDB存储引擎使用B+Tree实现其索引结构。索引分为两类：

**聚集型索引：**Clustered Index，指索引项的排序方式和表中数据记录排序方式一致的索引。每张表只能有一个聚集索引，聚集索引的叶子节点存储了整个行数据。

**辅助索引**：Secondary Index，也称非聚类索引、非簇集索引，一个表中可以拥有多个非聚集索引。叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，还存储了一个指向该行数据的聚集索引的值。

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构。

**与B-Tree比较**

B-Tree每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

**B+Tree相对于B-Tree有几点不同：**

- 非叶子节点只存储键值信息。
- 所有叶子节点之间都有一个链指针。
- 数据记录都存放在叶子节点中。
- 将B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录

![image-20200307113901332](/Users/zhoutaoo/Library/Application Support/typora-user-images/image-20200307113901332.png)

> 索引原理可参见：https://blog.csdn.net/u013235478/article/details/50625677

### SQL性能分析

#### 执行计划

```mysql
mysql> explain select * from t_asset_account_inf where cust_id='74fb9c6e6f2f478d9b44d6cabab52e46';
+----+-------------+---------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table               | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_asset_account_inf | NULL       | ref  | ix_cust_id    | ix_cust_id | 202     | const |    1 |   100.00 | NULL  |
+----+-------------+---------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

#### 性能分析器

```mysql
-- 查看分析器是否开启
show variables like 'profiling%';
-- 临时打开分析器
set profiling=1;
-- 查看所有分析的语句
mysql> show profiles;
+----------+------------+------------------------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                                              |
+----------+------------+------------------------------------------------------------------------------------+
|        1 | 0.00189075 | show variables like 'profiling%'                                                   |
|        2 | 0.00011300 | show profiling                                                                     |
|        3 | 0.00058900 | select * from t_asset_account_inf where cust_id='310bf60dfa49473cba74b85b5f2a5832' |
+----------+------------+------------------------------------------------------------------------------------+

-- 使用query id查看具体执行耗时的情况
show profile for query 3;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000090 |
| checking permissions | 0.000016 |
| Opening tables       | 0.000029 |
| init                 | 0.000050 |
| System lock          | 0.000022 |
| optimizing           | 0.000017 |
| statistics           | 0.000090 |
| preparing            | 0.000020 |
| executing            | 0.000010 |
| Sending data         | 0.000097 |
| end                  | 0.000019 |
| query end            | 0.000016 |
| closing tables       | 0.000015 |
| freeing items        | 0.000022 |
| cleaning up          | 0.000021 |
+----------------------+----------+
15 rows in set, 1 warning (0.00 sec)
```

### 开发设计规范讲解

见《数据开发设计规范》文档

#### 设计原则

#### 命名规则

#### SQL开发规范

#### 运维规范

#### 分库分表原则

### 开发运维手册讲解

见《数据开发运维手册》文档

#### 账号管理

#### DBA指南

#### 开发指南

#### 运维指南

## 分库分表

### 分库分表简介

顾名思义，分库分表就是按照一定的规则，对原有的数据库和表进行拆分，把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。

#### 为什么要分库分表

随着时间和业务的发展，数据库中的数据量增长是不可控的，库和表中的数据会越来越大，随之带来的是更高的磁盘、IO、系统开销，甚至性能上的瓶颈，而一台服务的资源终究是有限的，因此需要对数据库和表进行拆分，从而更好的提供数据服务。

### 分库分表类型

![image-20200307122508478](/Users/zhoutaoo/Library/Application Support/typora-user-images/image-20200307122508478.png)

#### 垂直分库/分表

垂直划分数据库是根据业务进行划分，例如将shop库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库（表）的大小来提高性能，但这种方式并没有解决高数据量带来的性能损耗。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如用户表可根据业务分成基本信息表和详细信息表等。

*优点*：

1. 拆分后业务清晰，达到专库专用。
2. 可以实现热数据和冷数据的分离，将不经常变化的数据和变动较大的数据分散再不同的库/表中。
3. 便于维护

*缺点*：

1. 不解决数据量大带来的性能损耗，读写压力依旧很大。
2. 单表数据量依旧大，查询性能提升不大。
3. 不同的业务无法跨库关联（join），只能通过业务来关联

#### 水平分库/分表

水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。又比如根据用户id的值，根据规则分成若干个表。每个表结构一致,（**这点与垂直分库分表相反**）。

优点：

1. 单库（表）的数据量得以减少，提高性能
2. 提高了系统的稳定性和负载能力
3. 切分出的表结构相同，程序改动较少

缺点：

1. 拆分规则较难抽象
2. 数据分片在扩容时需要迁移
3. 维护量增大
4. 依然存在跨库无法join等问题，同时涉及分布式事务，数据一致性等问题。

#### 分库分表方式

**①单库单表**

最常见的数据库设计，例如，有一张用户user表放在数据库db中，所有的用户都可以在db库中的user表中查到。

**②单库多表**

随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。 

可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。 

**③多库多表**

随着数据量增加也许单台DB的存储空间、连接数也不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。 

### 分库分表中间件

常见开源分库分表中间件：TDDL（淘宝），Sharding-JDBC（当当网），Mycat（基于Cobar）等等。

### Mycat简介

MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为N个小表，存储在后端MySQL服务器里或者其他数据库里。官网：http://mycat.io/

#### 关键特性

```
支持SQL92标准
支持MySQL、Oracle、DB2、SQL Server、PostgreSQL等DB的常见SQL语法
遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理。
基于心跳的自动故障切换，支持读写分离，支持MySQL主从，以及galera cluster集群。
支持Galera for MySQL集群，Percona Cluster或者MariaDB cluster
基于Nio实现，有效管理线程，解决高并发问题。
支持数据的多片自动路由与聚合，支持sum,count,max等常用的聚合函数,支持跨库分页。
支持单库内部任意join，支持跨库2表join，甚至基于caltlet的多表join。
支持通过全局表，ER关系的分片策略，实现了高效的多表join查询。
支持多租户方案。
支持分布式事务（弱xa）。
支持XA分布式事务（1.6.5）。
支持全局序列号，解决分布式下的主键生成问题。
分片规则丰富，插件化开发，易于扩展。
强大的web，命令行监控。
支持前端作为MySQL通用代理，后端JDBC方式支持Oracle、DB2、SQL Server 、 mongodb 、巨杉。
支持密码加密
支持服务降级
支持IP白名单
支持SQL黑名单、sql注入攻击拦截
支持prepare预编译指令（1.6）
支持非堆内存(Direct Memory)聚合计算（1.6）
支持PostgreSQL的native协议（1.6）
支持mysql和oracle存储过程，out参数、多结果集返回（1.6）
支持zookeeper协调主从切换、zk序列、配置zk化（1.6）
支持库内分表（1.6）
集群基于ZooKeeper管理，在线升级，扩容，智能优化，大数据处理（2.0开发版）。
```

### Mycat架构与搭建

见《centos下搭建mycat集群》文档

### 分库分表操作

见《数据库开发运维手册》文档

### 全局ID方案

#### 分布式ID的特性

- 全局唯一性：确保生成的ID是全网唯一的。
- 趋势递增：确保生成的ID是对于某个用户或者业务是按一定的数字有序递增的。
- 高可用性：确保任何时候都能正确的生成ID。
- 带时间：ID里面包含时间，一眼扫过去就知道哪天的交易。
- 信息安全：如果ID是连续递增的，恶意用户就可以很容易的窥见订单号的规则，从而猜出下一个订单号，如果是竞争对手，就可以直接知道我们一天的订单量。所以在某些场景下，需要ID无规则。

####  分布式ID生成方案

分布式ID生成方案有很多，如：Redis生成ID、UUID、数据库自增ID、snowflake算法等。

参考：https://youzhixueyuan.com/how-to-generate-distributed-unique-id.html

**snowflake算法**

![image-20200308113513887](/Users/zhoutaoo/Library/Application Support/typora-user-images/image-20200308113513887.png)

- **1位符号位：**

由于 long 类型在 java 中带符号的，最高位为符号位，正数为 0，负数为 1，且实际系统中所使用的ID一般都是正数，所以最高位为 0。

- **41位时间戳（毫秒级）：**

需要注意的是此处的 41 位时间戳并非存储当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 起始时间戳），这里的起始时间戳一般是ID生成器开始使用的时间戳，由程序来指定，所以41位毫秒时间戳最多可以使用 `(1 << 41) / (1000x60x60x24x365) = 69年`。

- **10位数据机器位：**

包括5位数据标识位和5位机器标识位，这10位决定了分布式系统中最多可以部署 `1 << 10 = 1024` s个节点。超过这个数量，生成的ID就有可能会冲突。

- **12位毫秒内的序列：**

这 12 位计数支持每个节点每毫秒（同一台机器，同一时刻）最多生成 `1 << 12 = 4096个ID`加起来刚好64位，为一个Long型。

- 优点：高性能，低延迟，按时间有序，一般不会造成ID碰撞
- 缺点：需要独立的开发和部署，强依赖于机器的时钟，如果机器上时钟回拨，可能会导致重复ID。