# mysql数据库设计规范

[toc]



## 一、设计原则

### 基本设计规范

#### 1.所有表必须使用Innodb存储引擎

极少数特殊业务需求除外
Innodb引擎是5.6之后的默认存储引擎；mysql5.5之前使用Myisam(默认存储引擎)
Innodb优点：支持事务，行级锁，更好的恢复性，高并发下性能更好

#### 2.数据库和表的字符集统一使用utf8mb4
数据库、表、字段字符集要统一，统一字符集可以避免由于字符集转换产生的乱码
校验集(Collation)默认选择utf8mb4_bin(值区分大小写)

#### 3.所有表和字段都需要添加注释

#### 4.尽量控制单表数据量大小

1. 建议控制在500万以内，虽然500万并不是mysql的数据库限制，但是会给修改表结构，备份，恢复带来很大困难。
2. 单表可存储数据量大小取决于存储设置和文件系统
3. 想减少单表数据量：历史数据归档(常见于日志表)，分库分表(常见于业务表)，分区表
4. 建议不要使用mysql分区表，因为分区表在物理上表现为多个文件，在逻辑上表现为一个表。如果一定要分区，请谨慎选择分区键，跨分区查询效率比查询大数据量的单表查询效率更低
5. 建议采物理分表的方式管理大数据，但是对应用程序的开发要求和复杂度更高

#### 5.尽量做到冷热数据分离，减少表的宽度(字段数)
1. 减少磁盘IO，保证热数据的内存缓存命中率，更有效的利用缓存，避免读入无用的冷数据
2. 这样的话，就要对表的列进行拆分，将经常使用的列放到一个表中，可以避免过多的关联操作，也可以提高查询性能

#### 6.禁止在表中建立预留字段

1. 预留字段很难做到见名知义，预留字段无法确定存储的数据类型，后期如果修改字段类型，会对全表锁定，严重影响数据库的并发性
2. 对目前mysql来说，修改一个字段的成本要远远大于增加一个字段的成本

#### 7.禁止在数据库中存储图片，文件等二级制数据
1. 这类数据如果要存，就得使用blog或者text这样的大字段加以存储，会影响数据库的性能
2. 文件这种通常所占数据容量很大，会在短时间内造成数据库文件的快速增长，而数据库在读取数据时，会进行大量的随机IO操作，如果数据文件过大，IO操作会非常耗时，从而影响数据库性能
3. 正确做法是将这类数据存储在文件服务器中，而数据库只村存储地址信息

#### 8.禁止在线上做数据库压力测试

1. 会对正常业务造成影响，也会产生很多垃圾数据
2. 建议建立专门的压力测试数据库，进行测试，然后对比测试服务器和线上服务器的硬件环境，评估线上数据库的性能

#### 9.禁止从开发环境，测试环境直连生产环境数据库

### 索引设计规范

#### 1.限制每张表上索引数量

建议单表不超过5个索引。索引并不是越多越好，可以提高查询效率，但是会降低插入和更新的效率。甚至在一些情况下，还会降低查询效率，因为mysql优化器在选择如何优化查询时，会根据统计信息，对每一个可用索引来进行评估，以生成一个最好的执行计划，如果同时有很多索引都可以用于查询，就会增加mysql查询优化器生成查询计划的时间。

#### 2.每个Innodb表都必须有一个主键。

Innodb是一种聚集索引组织表，是指数据存储的逻辑顺序和索引的顺序是相同，Innodb是按照主键索引的顺序来组织表的，因此，每个Innodb表都必须要有一个主键，如果我们没有指定主键，那么Innodb会优先选择表中第一个非空唯一索引来作为主键，如果没有这个索引，那么Innodb会自动生成一个占6字节的主键，而这个主键的性能并不是最好。

#### 3.不使用更新频繁的列作为主键，不使用多列联合主键。

因为Innodb是一种索引索引组织表，如果主键上的值频繁更新，就意味着数据存储的逻辑顺序频繁变动，必然会带来大量的IO操作，降低数据库性能。

#### 4.不要使用uuid，md5，hash，字符串列作为主键。

因为这种主键不能保证主键的值是顺序增长的，如果后来的主键值在已有主键值的中间段，那么这个主键插入的时候，会将所有主键值大于它的列都向后移。

#### 5.最好选择能保证值的顺序为顺序增长的列为主键。并且数据不能重复，建议用mysql自增id建立主键

#### 6.避免建立冗余索引和重复索引

#### 7.对于频繁的查询优先使用覆盖索引
就是包含了所有查询字段的索引，这样可以避免Innodb表进行索引的二次查找，并可以把随机IO变为顺序IO提高查询效率

#### 8.尽量避免使用外键

mysql和别的数据库不同，会自动在外键上建立索引，会降低数据库的写性能
建议不使用外键约束，但是一定要在表与表之间的关联键上建立索引，虽然外键是为了保证数据的完整性，但是最好在代码中去保证。

### 字段设计规范

#### 1.优先选择符合存储需要的最小的数据类型
1. 尽量将字符串转化为数字类型存储：如将ip存储为数字：inet_aton(‘255.255.255.255’) = 4294967295 ,反之， inet_ntoa(4294967295) = ‘255.255.255.255’
2. 对于非负整型数据，优先使用无符号整型来存储，如：id,age,无符号相对于有符号，可以多出一倍的存储空间
3. mysql中，varchar(n)中n表示字符数而不是字节数

#### 2.避免使用text，blog来存储字段

这种类型只能使用前缀索引，如果非要使用，建议将这种数据分离到单独的拓展表中

#### 3.避免使用enum类型

枚举本身是一个字符串类型，但是内部确是用正数类型来存储的，所以最多可存储65535种不同的值，修改的话必须使用alter语句，直接修改元数据，有操作风险；order by效率低，必须转换并无法使用索引，禁止使用数值作为enum值，因为enum本身是索引顺序存储的，会造成逻辑混淆
#### 4.尽可能把所有列定义为not null。
1. 索引null列需要额外的空间来保存，占更多空间。
2. 进行比较和计算时，对null值作特别的处理，可能造成索引失效。

#### 5.禁止使用字符串来存储日期型数据。
1. 无法使用日期函数计算比较
2. 字符串存储要占更多的内存空间，datetime(8字节)和timestamp(本身是以int存储，占4字节,范围:1970-01-01 00:00:01到2038-01-19 03:14:07)

#### 6.财务相关数据，使用decimal类型 (精准浮点类型，在计算时不丢失精度)。

## 二、设计与命名规范
### 1.数据库设计规范

1. 库名、表名、字段等对象命名全部小写，由英文字母、0-9、_ 组成，不能使用特殊字符、空格等。
2. 库名使用英文或英文缩写，禁止使用全数字编码、中文和拼音命名，要见名知意。
3. 库名、表名、字段等对象命名长度不超过20字符，尽量精减，方便书写。
4. 表、字段必须添加相关comment注释。
5. 数据库使用utf8mb4编码。

### 2.表设计规范

1. 主键命名为'id'，varchar(20)，不使用数据库的自增序列，应用生成全局自增序列赋值。

5. 必须包含4个审计字段且不能为空。created_date、updated_date、created_by、updated_by。

6. mysql关键词要求大写，可使用IDE如idea进行格式化。

7. 常量枚举全部用大写字符。

8. **临时表**必须以tmp_为前缀并以日期为后缀

6. **历史表**变更记录表使用_history结尾，如用户信息变更表user_history

7. **备份表**必须以_bak结尾并以日期为后缀

   ```mysql
   -- 表名：网关路由表
   -- 用途：用于网关的路由...
   -- 日期：2020-02-06
   CREATE TABLE gateway_route
   (
       id           VARCHAR(20) PRIMARY KEY COMMENT 'id',
       route_id     VARCHAR(100) NOT NULL COMMENT '路由id',
       uri          VARCHAR(100) NOT NULL COMMENT 'uri路径',
       description  VARCHAR(500) COMMENT '描述',
       status       VARCHAR(1)            DEFAULT 'Y' COMMENT '状态：Y-有效，N-无效',
       created_date DATETIME     NOT NULL DEFAULT now() COMMENT '创建时间',
       updated_date DATETIME     NOT NULL DEFAULT now() COMMENT '更新时间',
       created_by   VARCHAR(50) NOT NULL COMMENT '创建人',
       updated_by   VARCHAR(50) NOT NULL COMMENT '更新人'
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '网关路由表';
   
   CREATE UNIQUE INDEX ux_gateway_routes_uri ON gateway_route (uri);
   ```


### 3.索引命名规范

1. 唯一索引：ux_表名_索引字段。如：ux_resource_code
2. 普通索引：ix_表名_索引字段。如：ix_role_name
3. 外键命名：fk_表名_字段名。如：fk_orders_product_id

### 4.其它规范

1. 不使用触发器触发器的功能，通常可以用其他方式实现。
2. 不使用mysql外键，由程序控制关联关系，数据库外键会产生性能问题。
3. 不使用存储过程处理业务逻辑，业务逻辑由应用层代码处理。

### 5.字段规范

1. 表名全部小写，由26个英文字母和0-9组成，单词间通过'_'间隔，不要使用特殊字符、空格 。
2. 表名长度不超过20字符，尽量精减，方便书写。
3. 字段命名使用英文和英文缩写，禁止使用数字编码、中文和拼音命名不能是mysql保留字。
4. 字段必须添加相关comment注释。
5. 金额等需要小数精度的字段使用使用Decimal类型，不要使用float和double。
6. 日期优先使用datetime，不建议使用timestamp和字符串。
7. 常用字段定义通用的字段定义表，如多个表中都有customerId、userId等等。
8. 相同的意义的字段，在不同表中保持字段名和类型的一致性。
9. 如下字段定义可作参考，全系统统一标准。

| 名称类   | 类型     | 长度 | 备注               |
| -------- | -------- | ---- | ------------------ |
| 账号类   | varchar  | 50   | 如email，username  |
| 状态类   | varchar  | 5    | 如订单状态等       |
| 名称类   | varchar  | 100  | 如中文名称、产品名 |
| 手机电话 | varchar  | 12   |                    |
| 描述简介 | varchar  | 500  | 如备注、简介等     |
| 网址类   | varchar  | 500  | 如url              |
| 时间类   | datetime |      |                    |

### 7.数据库脚本文件规范

1. 数据库脚本提交代码版本库进行管理，按database建立目录，按迭代建立脚本文件，迭代与迭代间提交增量脚本，不修改上次迭代脚本。

2. 脚本文件使用utf8编码进行书写。

3. 脚本命名规范

   ``` basic
   sbux_asset_center
   ├── sprint0                     -- 迭代0
   │   ├── 01_ddl_asset_customer.sql
   │   └── 01_dml_asset_customer.sql
   ├── sprint1                     -- 迭代1
   └── sprint2                     -- 迭代2
   ```

### 8.索引使用原则

1) 不要索引blob/text等字段，不要索引大型字段(有很多字符)，这样作会让索引占用太多的存储空间，效率也很低下。

2) 不要索引常用的小型表，不要为小型数据表设置任何键，假如它们经常有插入和删除操作就更别这样作了。对这些插入和删除操作的索引维护可能比扫描表空间消耗更多的时间。

### 9.sql语句规范

1. 所有sql关键词全部大写,比如SELECT、UPDATE、FROM、ORDER、BY等
2. sql中的常量全部使用大写字符，如状态"Y"和"N"等。 

## 三、SQL开发规范

### 1.建议使用预编译语句(prepareStatment)进行数据库操作

1. 可以同步执行预编译计划，减少预编译时间
2. 可以有效避免动态sql带来的SQL注入的问题
3. 只传参数，一次解析，多次使用，比传递sql语句更高效

### 2.避免数据类型的隐式转换

一般出现在where从句中，会导致索引失效，如：select id,name from user where id = ‘12’;

### 3.充分利用已存在的索引

1. 避免使用双%的查询条件，不走索引
2. 一个SQL只能利用到复合索引中的一列进行范围查询
3. 使用left join或not exists来优化not in操作

### 4.程序连接不同的数据库使用不同的账号，禁止跨库查询
1. 为数据库迁移和分库分表留出余地
2. 降低业务耦合度
3. 避免权限过大而产生的安全风险

### 5.禁止使用select * 来查询，必须用字段名
1. 可能会消耗更多的cpu和IO以及网络资源
2. 无法使用覆盖索引
3. 可以减少表结构变更对已有程序的影响

### 6.禁止使用不含字段列表的insert语句。

1. 可以减少表结构变更对已有程序的影响

### 7.禁止使用子查询
1. 虽然可使sql可读性好，但是缺点远远大于优点
2. 子查询返回的结果集无法使用索引，结果集会被存储到一个临时表中，结果集越大性能越低
3. 把子查询优化为join操作，但是并不是所有的都可以优化为join，一般情况下，只有当子查询是在in子句中，并且子查询是一个简单的sql(不包含union，group by，order by，limit)才能转换为关联查询

### 8.避免join过多的表
1. 每join一个表会占一部分内存(join_buffer_size)
2. 会产生临时表操作，影响查询效率
3. mysql最多允许关联61个表，建议不超过3个

### 9.减少同数据库的交互次数
1. 数据库更适合处理批量操作
2. 合并多个相同的操作到一起，提高处理效率

### 10.使用in代替or

1. in的值不要超过500个
2. in 操作可以有效利用索引

### 11.禁止使用order by rand()进行随机排序

1. 会把表中所有符合条件的数据装载到内存中进行排序
2. 会消耗大量的cpu和io及内存资源
3. 推荐在程序中获取随机值

### 12.禁止在where从句中对列进行函数转换和计算

1. 导致无法使用相关列上的索引
2. where date(create_time)=’20170901’ 写成 where create_time >= ‘20170901’ and create_time < ‘20170902’

### 13.在明显不会有重复值时使用union all而不是union

1. union 会把所有数据放在临时表中后再进行去重操作，会多消耗内存，IO，网络资源
2. union all 不会再对结果集进行去重操作

### 14.拆分复杂的大sql为多个小sql

1. 目前mysql中一个sql只能使用一个cpu计算，不支持多cpu并行计算
2. sql拆分后可以通过并行执行来提高处理效率

## 四、 数据库操作行为规范

### 1.超过100万的批量写操作，要分批多次进行操作

1. 主从复制中：大批量操作可能会造成严重的主从延迟，因为当主库执行完成后，才会在从库执行
2. binlog日志为row格式时会产生大量的日志
3. 避免产生大量事务，产生阻塞，占满可用连接

### 2.对大表数据结构的修改一定要谨慎

1. 可能会造成严重的锁表操作，尤其是生产环境，是不能忍受的

2. 对于大表使用pt-online-schema-change修改表结构：

   首先会建立一个与原表结构相同的新表

   然后在新表上进行表结构的修改

   然后把原表中的数据复制到新表中，并且增加一些触发器，以便把原表中即时新增的数据也复制到新表中

   在行的所有数据复制完成之后，会在原表上增加一个很准的时间锁，同时把新表命名为原表，把原表删掉

   实际上是把一个原子的DDL操作分解成多批次进行

3. 避免大表修改产生的主从延迟问题

4. 避免在对表字段进行修改时进行锁表

### 3.禁止为程序使用的账号赋予super权限

1. 当数据库连接数达到最大限制时，允许1个有super权限的用户连接
2. super权限只能留给DBA处理问题的账号使用

### 4.对于程序连接数据库账号，遵循权限最小原则

1. 程序使用的数据库账号只能在一个DB下使用，不准跨库
2. 程序使用的账号原则上不准有drop权限

## 五、分库分表原则

 第一步：采用缓存redis等降低对数据库的读操作。

 第二步：如果缓存使用过后，数据库访问量还是非常大，可以考虑数据库读、写分离原则。

 第三步：当我们使用读写分离、缓存后，数据库的压力还是很大的时候，这就需要使用到数据库拆分了。

 第四步：首先考虑按照业务垂直拆分，再考虑水平拆分：先分库(按业务领域把数据分配到不同的库中)，最后再考虑分表，单表拆分到数据1000万以内。

### 垂直切分

一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面。

由于垂直切分是按照业务的分类将表分散到不同的库，所以有些业务表会过于庞大，存在单库读写与存储瓶颈，所以就需要水平拆分来做解决。如客户信息单独的库和应用，交易库和其应用，按业务领域拆分。

### 水平切分

按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中。

第一原则：能不切分尽量不要切分。 

第二原则：如果要切分一定要选择合适的切分规则，提前规划好。 

第三原则：数据切分尽量通过数据冗余或表分组（Table Group）来降低跨库 Join 的可能。

 第四原则：由于数据库中间件对数据 Join 实现的优劣难以把握，而且实现高性能难度极大，业务读取尽量少使用多表 Join。

可按如下表格进行表信息的收集进行分析评估是否分库分表，以什么条件分。

| 表     | 存量数据 | 每日增量 | 每年增量 | 主要查询条件               |
| ------ | -------- | -------- | -------- | -------------------------- |
| 流水表 | 1000万   | 30万     | 6000万   | created_date、trans_no、id |
|        |          |          |          |                            |

#### 水平切分种类：

* 全局表：类似字典表的表，这些表基本上很少变动，总体数据量小于10万。可能需要跟其它表进行join

* 分片表：是指那些原有的很大数据的表，需要切分到多个数据库的表，这样每个分片都有一部分数据，所有分片构成了完整的数据。
* 父子表：子表的记录与所关联的父表记录存放在同一个数据分片上，即子表依赖于父表，通过表分组（Table Group）保证数据 Join 不会跨库操作。
* 孤立表：数据库中并不是所有的表都很大，某些表是可以不用进行切分的，就是那些不需要进行数据切分的表